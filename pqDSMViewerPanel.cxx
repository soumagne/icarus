/*=========================================================================

  Project                 : Icarus
  Module                  : pqDSMViewerPanel.cxx

  Authors:
     John Biddiscombe     Jerome Soumagne
     biddisco@cscs.ch     soumagne@cscs.ch

  Copyright (C) CSCS - Swiss National Supercomputing Centre.
  You may use modify and and distribute this code freely providing
  1) This copyright notice appears on all copies of source code
  2) An acknowledgment appears with any substantial usage of the code
  3) If this code is contributed to any other open source project, it
  must not be reformatted such that the indentation, bracketing or
  overall style is modified significantly.

  This software is distributed WITHOUT ANY WARRANTY; without even the
  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  This work has received funding from the European Community's Seventh
  Framework Programme (FP7/2007-2013) under grant agreement 225967 “NextMuSE”

=========================================================================*/
#include "pqDSMViewerPanel.h"

// Qt includes
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QVariant>
#include <QSpinBox>
#include <QDoubleSpinBox>
#include <QLabel>
#include <QComboBox>
#include <QTableWidget>
#include <QMessageBox>
#include <QProgressDialog>
#include <QTimer>
#include <QInputDialog>
#include <QFileDialog>
#include <QUrl>
#include <QDesktopServices>
#include <QThread>
#include <QTime>

// VTK includes

// ParaView Server Manager includes
#include "vtkSMInputProperty.h"
#include "vtkSMProxyManager.h"
#include "vtkSMSourceProxy.h"
#include "vtkSMStringVectorProperty.h"
#include "vtkSMIntVectorProperty.h"
#include "vtkSMArraySelectionDomain.h"
#include "vtkSMProxyProperty.h"
#include "vtkSMViewProxy.h"
#include "vtkSMRepresentationProxy.h"
#include "vtkProcessModule.h"
#include "vtkProcessModuleConnectionManager.h"

// ParaView includes
#include "pqActiveServer.h"
#include "pqApplicationCore.h"
#include "pqSettings.h"
#include "pqOutputPort.h"
#include "pqPipelineSource.h"
#include "pqPropertyLinks.h"
#include "pqProxy.h"
#include "pqServer.h"
#include "pqServerManagerSelectionModel.h"
#include "pqServerManagerModelItem.h"
#include "pqServerManagerModel.h"
#include "pqSMAdaptor.h"
#include "pqTreeWidgetCheckHelper.h"
#include "pqTreeWidgetItemObject.h"
#include "pqTreeWidget.h"
#include "pqTreeWidgetItem.h"
#include "pqView.h"
#include "pqRenderView.h"
#include "pqActiveView.h"
#include "pqDataRepresentation.h"
#include "pqActiveObjects.h"
#include "pqDisplayPolicy.h"
#include "pqAnimationScene.h"
//
#include "pqObjectInspectorWidget.h"
#include "pqAutoGeneratedObjectPanel.h"
#include "pqNamedWidgets.h"
#include "pq3DWidget.h"
//
#include "pq3DWidgetInterface.h"
#include "pqBoxWidget.h"
#include "pqDistanceWidget.h"
#include "pqImplicitPlaneWidget.h"
#include "pqLineSourceWidget.h"
#include "pqPointSourceWidget.h"
#include "pqSphereWidget.h"
#include "pqSplineWidget.h"
//
#include "ui_pqDSMViewerPanel.h"
#include "H5FDdsmComm.h"
#include "XdmfSteeringParser.h"
#include "XdmfSteeringIntVectorProperty.h"
#include "XdmfSteeringDoubleVectorProperty.h"
#include "XdmfSteeringBooleanDomain.h"
#include "XdmfSteeringIntRangeDomain.h"
#include "XdmfSteeringDoubleRangeDomain.h"
#include "XdmfSteeringEnumerationDomain.h"

#include <vtksys/SystemTools.hxx>

using std::vector;

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
class pqDSMViewerPanel::pqUI : public QObject, public Ui::DSMViewerPanel 
{
public:
  pqUI(pqDSMViewerPanel* p) : QObject(p)
  {
    this->Links = new pqPropertyLinks;
    this->DSMInitialized   = 0;
    this->ActiveSourcePort = 0;
    this->ActiveServer     = 0;
    this->ActiveView       = 0;
    this->ObjectInspector  = 0;
    this->pqObjectInspectorProxy = 0;
  }
  //
  ~pqUI() {
    delete this->Links;
    this->DSMProxy          = NULL;
    this->DSMProxyHelper    = NULL;
    this->ActiveSourceProxy = NULL;
  }

  void CreateProxy() {
    vtkSMProxyManager *pm = vtkSMProxy::GetProxyManager();
    this->DSMProxy = pm->NewProxy("icarus_helpers", "DSMManager");
    this->DSMProxy->UpdatePropertyInformation();
  }

  //
  bool ProxyCreated() { return this->DSMProxy!=NULL; }
  pqPropertyLinks            *Links;
  int                         DSMInitialized;
  vtkSmartPointer<vtkSMProxy> DSMProxy;
  vtkSmartPointer<vtkSMProxy> DSMProxyHelper;
  vtkSmartPointer<vtkSMProxy> ActiveSourceProxy;
  pqObjectInspectorWidget    *ObjectInspector;
  pqProxy                    *pqObjectInspectorProxy;
  int                         ActiveSourcePort;
  pqServer                   *ActiveServer;
  pqRenderView               *ActiveView;
};
//-----------------------------------------------------------------------------
class dsmStandardWidgets : public pq3DWidgetInterface
{
public:
  pq3DWidget* newWidget(const QString& name,
    vtkSMProxy* referenceProxy,
    vtkSMProxy* controlledProxy)
    {
    pq3DWidget *widget = 0;
    if (name == "Plane")
      {
      widget = new pqImplicitPlaneWidget(referenceProxy, controlledProxy, 0);
      }
    else if (name == "Box")
      {
      widget = new pqBoxWidget(referenceProxy, controlledProxy, 0);
      }
    else if (name == "Handle")
      {
      widget = new pqHandleWidget(referenceProxy, controlledProxy, 0);
      }
    else if (name == "PointSource")
      {
      widget = new pqPointSourceWidget(referenceProxy, controlledProxy, 0);
      }
    else if (name == "LineSource")
      {
      widget = new pqLineSourceWidget(referenceProxy, controlledProxy, 0);
      }
    else if (name == "Line")
      {
      widget = new pqLineWidget(referenceProxy, controlledProxy, 0);
      }
    else if (name == "Distance")
      {
      widget = new pqDistanceWidget(referenceProxy, controlledProxy, 0);
      }
    else if (name == "Sphere")
      {
      widget = new pqSphereWidget(referenceProxy, controlledProxy, 0);
      }
    else if (name == "Spline")
      {
      widget = new pqSplineWidget(referenceProxy, controlledProxy, 0);
      }
    return widget;
    }
};
//-----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
pqDSMViewerPanel::pqDSMViewerPanel(QWidget* p) :
QDockWidget("DSM Manager", p)
{
  this->UI = new pqUI(this);
  this->UI->setupUi(this);

  this->Connected       = false;
  this->DSMCommType     = 0;
  this->CurrentTimeStep = 0;
  this->UpdateTimer = new QTimer(this);
  this->UpdateTimer->setInterval(0);
  connect(this->UpdateTimer, SIGNAL(timeout()), this, SLOT(onUpdateTimeout()));
  this->UpdateTimer->start();

  this->SteeringParser = new XdmfSteeringParser();

  this->HTMScene = new QGraphicsScene();
  this->UI->dsmHTMView->setScene(this->HTMScene);
  this->HTMScene->addText("HTM view to be displayed here!");

  QGraphicsView view(this->HTMScene);
  view.show();

  //
  // Link GUI object events to callbacks
  //

  // XDMF XML Commands
  this->connect(this->UI->browseFile,
    SIGNAL(clicked()), this, SLOT(onBrowseFile()));

  // Auto Save image
  this->connect(this->UI->browseFileImage,
    SIGNAL(clicked()), this, SLOT(onBrowseFileImage()));

  this->connect(this->UI->autoSaveImage,
    SIGNAL(stateChanged(int)), this, SLOT(onautoSaveImageChecked(int)));

  // 3D widget
//  this->connect(this->UI->displayWidget,
//    SIGNAL(stateChanged(int)), this, SLOT(toggleHandleWidget(int)));
  
  // DSM Commands
  this->connect(this->UI->addServerDSM,
      SIGNAL(clicked()), this, SLOT(onAddServerDSM()));

  this->connect(this->UI->publishDSM,
    SIGNAL(clicked()), this, SLOT(onPublishDSM()));

  this->connect(this->UI->unpublishDSM,
    SIGNAL(clicked()), this, SLOT(onUnpublishDSM()));

  // Steering commands
  this->connect(this->UI->scRestart,
      SIGNAL(clicked()), this, SLOT(onSCRestart()));

  this->connect(this->UI->scPause,
      SIGNAL(clicked()), this, SLOT(onSCPause()));

  this->connect(this->UI->scPlay,
      SIGNAL(clicked()), this, SLOT(onSCPlay()));

  this->connect(this->UI->dsmWriteDisk,
      SIGNAL(clicked()), this, SLOT(onSCWriteDisk()));

  this->connect(this->UI->dsmArrayTreeWidget,
      SIGNAL(itemChanged(QTreeWidgetItem*, int)), this, SLOT(onArrayItemChanged(QTreeWidgetItem*, int)));

  this->connect(this->UI->writeToDSM,
      SIGNAL(clicked()), this, SLOT(onWriteDataToDSM()));

//  this->connect(this->UI->advancedControlUpdate,
//        SIGNAL(clicked()), this, SLOT(onAdvancedControlUpdate()));
  //
  // Link paraview events to callbacks
  //
  pqServerManagerModel* smModel =
    pqApplicationCore::instance()->getServerManagerModel();

  this->connect(smModel, SIGNAL(serverAdded(pqServer*)),
    this, SLOT(onServerAdded(pqServer*)));

  this->connect(&pqActiveObjects::instance(),
    SIGNAL(serverChanged(pqServer*)),
    this, SLOT(onActiveServerChanged(pqServer*)));

  this->connect(smModel, SIGNAL(aboutToRemoveServer(pqServer *)),
    this, SLOT(StartRemovingServer(pqServer *)));

  //
  //
  //
  ////////////
  //keep self up to date whenever a new source becomes the active one
  pqServerManagerSelectionModel *selection =
    pqApplicationCore::instance()->getSelectionModel();

  this->connect(selection, 
    SIGNAL(currentChanged(pqServerManagerModelItem*)), 
    this, SLOT(TrackSource())
    );

  this->connect(smModel,
    SIGNAL(sourceAdded(pqPipelineSource*)),
    this, SLOT(TrackSource()));

  this->connect(smModel,
    SIGNAL(sourceRemoved(pqPipelineSource*)),
    this, SLOT(TrackSource()));

  // Track the active view so we can display contents in it
  QObject::connect(&pqActiveView::instance(),
    SIGNAL(changed(pqView*)),
    this, SLOT(onActiveViewChanged(pqView*)));

  //
  this->LoadSettings();
}
//----------------------------------------------------------------------------
pqDSMViewerPanel::~pqDSMViewerPanel()
{
  this->SaveSettings();

  this->DeleteSteeringWidgets();

  if (this->UpdateTimer) delete this->UpdateTimer;
  this->UpdateTimer = NULL;

  if (this->SteeringParser) delete this->SteeringParser;
  this->SteeringParser = NULL;

  if (this->HTMScene) delete this->HTMScene;
  this->HTMScene = NULL;

  if (this->UI->ProxyCreated()) {
    this->UI->DSMProxy->InvokeCommand("DestroyDSM");
    this->UI->DSMProxy = NULL;
    this->UI->DSMInitialized = 0;
  }

  this->XdmfReader = NULL;
  this->XdmfRepresentation = NULL;
  this->HandleProxy = NULL;
  this->HandleWidget = NULL;

}
//----------------------------------------------------------------------------
void pqDSMViewerPanel::LoadSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("DSMManager");
  int size = settings->beginReadArray("Servers");
  if (size>0) {
    for (int i=0; i<size; ++i) {
      settings->setArrayIndex(i);
      QString server = settings->value("server").toString();
      if (this->UI->dsmServerName->findText(server) < 0) {
        this->UI->dsmServerName->addItem(server);
      }
    }
  }
  settings->endArray();
  // Active server
  this->UI->dsmServerName->setCurrentIndex(settings->value("Selected", 0).toInt());
  // Size
  this->UI->dsmSizeSpinBox->setValue(settings->value("Size", 0).toInt());
  // Method
  this->UI->xdmfCommTypeComboBox->setCurrentIndex(settings->value("Communication", 0).toInt());
  // Port
  this->UI->xdmfCommPort->setValue(settings->value("Port", 0).toInt());
  // Client/Server/Standalone
  this->UI->dsmIsServer->setChecked(settings->value("dsmServer", 0).toBool());
  this->UI->dsmIsClient->setChecked(settings->value("dsmClient", 0).toBool());
  this->UI->dsmIsStandalone->setChecked(settings->value("dsmStandalone", 0).toBool());
  // Description file type
  this->UI->xdmfFileTypeComboBox->setCurrentIndex(settings->value("DescriptionFileType", 0).toInt());
  // Description file path
  QString descFilePath = settings->value("DescriptionFilePath").toString();
  if(!descFilePath.isEmpty()) {
    this->UI->xdmfFilePathLineEdit->insert(descFilePath);
    this->DescFileParse(descFilePath.toStdString().c_str());
  }
  // Force XDMF Generation
  this->UI->forceXdmfGeneration->setChecked(settings->value("ForceXDMFGeneration", 0).toBool());
  // Image Save
  this->UI->autoSaveImage->setChecked(settings->value("AutoSaveImage", 0).toBool());
  QString imageFilePath = settings->value("ImageFilePath").toString();
  if(!imageFilePath.isEmpty()) {
    this->UI->imageFilePath->insert(imageFilePath);
  }
  settings->endGroup();
}
//----------------------------------------------------------------------------
void pqDSMViewerPanel::SaveSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("DSMManager");
  // servers
  settings->beginWriteArray("Servers");
  for (int i=0; i<this->UI->dsmServerName->model()->rowCount(); i++) {
    settings->setArrayIndex(i);
    settings->setValue("server", this->UI->dsmServerName->itemText(i));
  }
  settings->endArray();
  // Active server
  settings->setValue("Selected", this->UI->dsmServerName->currentIndex());
  // Size
  settings->setValue("Size", this->UI->dsmSizeSpinBox->value());
  // Method
  settings->setValue("Communication", this->UI->xdmfCommTypeComboBox->currentIndex());
  // Port
  settings->setValue("Port", this->UI->xdmfCommPort->value());
  // Client/Server/Standalone
  settings->setValue("dsmServer", this->UI->dsmIsServer->isChecked());
  settings->setValue("dsmClient", this->UI->dsmIsClient->isChecked());
  settings->setValue("dsmStandalone", this->UI->dsmIsStandalone->isChecked());
  // Description file type
  settings->setValue("DescriptionFileType", this->UI->xdmfFileTypeComboBox->currentIndex());
  // Description file path
  settings->setValue("DescriptionFilePath", this->UI->xdmfFilePathLineEdit->text());
  // Force XDMF Generation
  settings->setValue("ForceXDMFGeneration", this->UI->forceXdmfGeneration->isChecked());
  // Image Save
  settings->setValue("AutoSaveImage", this->UI->autoSaveImage->isChecked());
  settings->setValue("ImageFilePath", this->UI->imageFilePath->text());
  //
  settings->endGroup();
}
//----------------------------------------------------------------------------
void pqDSMViewerPanel::DeleteSteeringWidgets()
{
  // Delete old tree
  for(int i = 0; i < this->UI->dsmArrayTreeWidget->topLevelItemCount(); i++) {
    QTreeWidgetItem *gridItem;
    gridItem = this->UI->dsmArrayTreeWidget->topLevelItem(i);
    for (int j = 0; j < gridItem->childCount(); j++) {
      QTreeWidgetItem *attributeItem = gridItem->child(j);
      gridItem->removeChild(attributeItem);
      if (attributeItem) delete attributeItem;
      attributeItem = NULL;
    }
    this->UI->dsmArrayTreeWidget->removeItemWidget(gridItem, 0);
    if (gridItem) delete gridItem;
    gridItem = NULL;
  }

  // clear out auto generated controls
  delete this->UI->ObjectInspector;
  delete this->UI->pqObjectInspectorProxy;
  this->UI->ObjectInspector        = NULL;
  this->UI->pqObjectInspectorProxy = NULL;

/*
  // First delete old created widgets
  while (!this->advancedControlIntScalarSpinBoxesLabels.empty()) {
    QLabel *label = this->advancedControlIntScalarSpinBoxesLabels.back();
    this->advancedControlIntScalarSpinBoxesLabels.pop_back();
    if (label) delete label;
    label = NULL;
  }
  while (!this->advancedControlIntScalarComboBoxesLabels.empty()) {
    QLabel *label = this->advancedControlIntScalarComboBoxesLabels.back();
    this->advancedControlIntScalarComboBoxesLabels.pop_back();
    if (label) delete label;
    label = NULL;
  }
  while (!this->advancedControlIntScalarSpinBoxes.empty()) {
    QSpinBox *spinBox = this->advancedControlIntScalarSpinBoxes.back();
    this->advancedControlIntScalarSpinBoxes.pop_back();
    if (spinBox) delete spinBox;
    spinBox = NULL;
  }
  while (!this->advancedControlIntScalarComboBoxes.empty()) {
    QComboBox *comboBox = this->advancedControlIntScalarComboBoxes.back();
    this->advancedControlIntScalarComboBoxes.pop_back();
    if (comboBox) delete comboBox;
    comboBox = NULL;
  }
  while (!this->advancedControlDoubleScalarLabels.empty()) {
    QLabel *label = this->advancedControlDoubleScalarLabels.back();
    this->advancedControlDoubleScalarLabels.pop_back();
    if (label) delete label;
    label = NULL;
  }
  while (!this->advancedControlDoubleScalarSpinBoxes.empty()) {
    QDoubleSpinBox *spinBox = this->advancedControlDoubleScalarSpinBoxes.back();
    this->advancedControlDoubleScalarSpinBoxes.pop_back();
    if (spinBox) delete spinBox;
    spinBox = NULL;
  }
  */
}
//----------------------------------------------------------------------------
void pqDSMViewerPanel::DescFileParse(const char *filepath)
{
  xmfSteeringConfig *steeringConfig;
  //
  this->DeleteSteeringWidgets();
  //
  this->SteeringParser->Parse(filepath);
  steeringConfig = this->SteeringParser->GetSteeringConfig();
  if (!steeringConfig) return;
  //
  this->UI->dsmArrayTreeWidget->setColumnCount(1);
  QList<QTreeWidgetItem *> gridItems;
  for (int i = 0; i < steeringConfig->numberOfGrids; i++) {
    QTreeWidgetItem *gridItem;
    QList<QTreeWidgetItem *> attributeItems;

    gridItem = new QTreeWidgetItem((QTreeWidget*)0, QStringList(QString(steeringConfig->gridConfig[i].gridName.c_str())));
    // Do not make grids selectable
    // gridItem->setCheckState(0, Qt::Checked);
    gridItems.append(gridItem);

    for (int j = 0; j < steeringConfig->gridConfig[i].numberOfAttributes; j++) {
      QTreeWidgetItem *attributeItem = new QTreeWidgetItem(gridItem, QStringList(QString(steeringConfig->gridConfig[i].attributeConfig[j].attributeName.c_str())));
      attributeItem->setCheckState(0, Qt::Checked);
      gridItems.append(attributeItem);
    }
  }

  //
  // The active view is very important once we start generating proxies to control
  // widgets etc. Make sure it is valid.
  // 
  if (this->UI->ActiveView==NULL && pqActiveView::instance().current()) {
    this->onActiveViewChanged(pqActiveView::instance().current());
  }

  // Create a DSM proxy helper object (interacts with generated Steering Objects)
  vtkSMProxyManager *pm = vtkSMProxy::GetProxyManager();
  this->UI->DSMProxyHelper = pm->NewProxy("icarus_helpers", "DSMProxyHelper");
  this->UI->DSMProxyHelper->SetConnectionID(pqActiveObjects::instance().activeServer()->GetConnectionID());
  // Set the DSM manager it uses for communication
  pqSMAdaptor::setProxyProperty(
    this->UI->DSMProxyHelper->GetProperty("DSMManager"), this->UI->DSMProxy);
  this->UI->DSMProxyHelper->UpdateVTKObjects();
  // wrap the object in a pqProxy
  this->UI->pqObjectInspectorProxy = new pqProxy("icarus_helpers", "DSMProxyHelper", this->UI->DSMProxyHelper, this->UI->ActiveServer); 
  //
  // create an object inspector to manage the settings
  //
  this->UI->ObjectInspector = new pqObjectInspectorWidget(this->UI->devTab);
  this->UI->ObjectInspector->setView(this->UI->ActiveView);
  this->UI->ObjectInspector->setProxy(this->UI->pqObjectInspectorProxy);
  this->UI->ObjectInspector->setDeleteButtonVisibility(false);
  this->UI->generatedLayout->addWidget(this->UI->ObjectInspector);

/*
  for (int i = 0; i < steeringConfig->interactConfig.numberOfIntVectorProperties; i++) {
    // TODO Handle vectors and not only scalars
    QGridLayout *gridLayout = dynamic_cast<QGridLayout*>(this->UI->advancedControlBox->layout());
    QLabel *label = new QLabel();
    label->setText(steeringConfig->interactConfig.intVectorProperties[i]->GetXMLName());
    gridLayout->addWidget(label, i, 0);
    if (steeringConfig->interactConfig.intVectorProperties[i]->GetDomain("enum")) {
      XdmfSteeringEnumerationDomain *enumDomain = dynamic_cast<XdmfSteeringEnumerationDomain*>(steeringConfig->interactConfig.intVectorProperties[i]->GetDomain("enum"));
      QComboBox *comboBox = new QComboBox();
      for (unsigned int entryIdx = 0; entryIdx < enumDomain->GetNumberOfEntries(); entryIdx++) {
        comboBox->addItem(enumDomain->GetEntryText(entryIdx));
      }
      comboBox->setCurrentIndex(steeringConfig->interactConfig.intVectorProperties[i]->GetElement(0));
      comboBox->setToolTip(steeringConfig->interactConfig.intVectorProperties[i]->GetDocumentation());
      gridLayout->addWidget(comboBox, i, 1);
      advancedControlIntScalarComboBoxes.push_back(comboBox);
      advancedControlIntScalarComboBoxesLabels.push_back(label);
    } else {
    QSpinBox *spinBox = new QSpinBox();
    if (steeringConfig->interactConfig.intVectorProperties[i]->GetDomain("bool")) {
      spinBox->setMinimum(0);
      spinBox->setMaximum(1);
    }
    if (steeringConfig->interactConfig.intVectorProperties[i]->GetDomain("range")) {
      XdmfSteeringIntRangeDomain *rangeDomain = dynamic_cast<XdmfSteeringIntRangeDomain*>(steeringConfig->interactConfig.intVectorProperties[i]->GetDomain("range"));
      spinBox->setMinimum(rangeDomain->GetMinimum(0));
      spinBox->setMaximum(rangeDomain->GetMaximum(0));
    }
    spinBox->setValue(steeringConfig->interactConfig.intVectorProperties[i]->GetElement(0));
    spinBox->setToolTip(steeringConfig->interactConfig.intVectorProperties[i]->GetDocumentation());
    gridLayout->addWidget(spinBox, i, 1);
    advancedControlIntScalarSpinBoxes.push_back(spinBox);
    advancedControlIntScalarSpinBoxesLabels.push_back(label);
    }
  }

  for (int i = 0; i < steeringConfig->interactConfig.numberOfDoubleVectorProperties; i++) {
    // TODO Handle vectors and not only scalars
    QGridLayout *gridLayout = dynamic_cast<QGridLayout*>(this->UI->advancedControlBox->layout());
    QDoubleSpinBox *spinBox = new QDoubleSpinBox();
    if (steeringConfig->interactConfig.doubleVectorProperties[i]->GetDomain("range")) {
      XdmfSteeringDoubleRangeDomain *rangeDomain = dynamic_cast<XdmfSteeringDoubleRangeDomain*>(steeringConfig->interactConfig.doubleVectorProperties[i]->GetDomain("range"));
      spinBox->setMinimum(rangeDomain->GetMinimum(0));
      spinBox->setMaximum(rangeDomain->GetMaximum(0));
    }
    spinBox->setDecimals(10);
    spinBox->setValue(steeringConfig->interactConfig.doubleVectorProperties[i]->GetElement(0));
    spinBox->setToolTip(steeringConfig->interactConfig.doubleVectorProperties[i]->GetDocumentation());
    QLabel *label = new QLabel();
    label->setText(steeringConfig->interactConfig.doubleVectorProperties[i]->GetXMLName());
    gridLayout->addWidget(label, i+steeringConfig->interactConfig.numberOfIntVectorProperties, 0);
    gridLayout->addWidget(spinBox, i+steeringConfig->interactConfig.numberOfIntVectorProperties, 1);
    advancedControlDoubleScalarLabels.push_back(label);
    advancedControlDoubleScalarSpinBoxes.push_back(spinBox);
  }
*/
  this->UI->dsmArrayTreeWidget->clear();
  this->UI->dsmArrayTreeWidget->insertTopLevelItems(0, gridItems);
  this->UI->dsmArrayTreeWidget->expandAll();
}
//----------------------------------------------------------------------------
void pqDSMViewerPanel::onServerAdded(pqServer *server)
{
  this->UI->ActiveServer = server;
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onActiveServerChanged(pqServer* server)
{
  this->UI->ActiveServer = server;
}
//----------------------------------------------------------------------------
void pqDSMViewerPanel::StartRemovingServer(pqServer *server)
{
  if (this->UI->ProxyCreated()) {
    this->UI->DSMProxy->InvokeCommand("DestroyDSM");
    this->UI->DSMProxy = NULL;
    this->UI->DSMInitialized = 0;
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onActiveViewChanged(pqView* view)
{
  pqRenderView* renView = qobject_cast<pqRenderView*>(view);
  this->UI->ActiveView = renView;
  if (this->HandleWidget && this->UI->ActiveView) {
    this->HandleWidget->setView(this->UI->ActiveView);
  }
}
//----------------------------------------------------------------------------
void pqDSMViewerPanel::LinkServerManagerProperties()
{
  // TBD
}
//---------------------------------------------------------------------------
bool pqDSMViewerPanel::ProxyReady()
{
  if (!this->UI->ProxyCreated()) {
    this->UI->CreateProxy();
    this->LinkServerManagerProperties();
    return this->UI->ProxyCreated();
  }
  return true;
}
//---------------------------------------------------------------------------
bool pqDSMViewerPanel::DSMReady()
{
  if (!this->ProxyReady()) return 0;
  //
  if (!this->UI->DSMInitialized) {
    //
    bool server = (this->UI->dsmIsServer->isChecked() || this->UI->dsmIsStandalone->isChecked());
    bool client = (this->UI->dsmIsClient->isChecked() || this->UI->dsmIsStandalone->isChecked());
    pqSMAdaptor::setElementProperty(
      this->UI->DSMProxy->GetProperty("DsmIsServer"), server);
    //
    if (server) {
      if (this->UI->xdmfCommTypeComboBox->currentText() == QString("MPI")) {
        this->DSMCommType = H5FD_DSM_COMM_MPI;
      }
      else if (this->UI->xdmfCommTypeComboBox->currentText() == QString("Sockets")) {
        this->DSMCommType = H5FD_DSM_COMM_SOCKET;
      }
      else if (this->UI->xdmfCommTypeComboBox->currentText() == QString("MPI_RMA")) {
        this->DSMCommType = H5FD_DSM_COMM_MPI_RMA;
      }
      pqSMAdaptor::setElementProperty(
        this->UI->DSMProxy->GetProperty("DsmCommType"),
        this->DSMCommType);
      //
      pqSMAdaptor::setElementProperty(
        this->UI->DSMProxy->GetProperty("DsmLocalBufferSize"),
        this->UI->dsmSizeSpinBox->value());
      //
      this->UI->DSMProxy->UpdateVTKObjects();
      this->UI->DSMProxy->InvokeCommand("CreateDSM");
      this->UI->DSMInitialized = 1;
    }
    else if (client) {
      this->UI->DSMProxy->InvokeCommand("ReadDSMConfigFile");
      this->UI->DSMProxy->InvokeCommand("CreateDSM");
      this->UI->DSMProxy->InvokeCommand("ConnectDSM");
      this->UI->DSMInitialized = 1;
    }
    // 
    if (server && client) {
//      this->onPublishDSM();
//      this->UI->DSMProxy->InvokeCommand("ConnectDSM");
    }
  }
  return this->UI->DSMInitialized;
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onAddServerDSM()
{
  QString servername = QInputDialog::getText(this, tr("Add DSM Server"),
            tr("Please enter the host name or IP address of a DSM server you want to add/remove:"), QLineEdit::Normal);
  if ((this->UI->dsmServerName->findText(servername) < 0) && !servername.isEmpty()) {
    this->UI->dsmServerName->addItem(servername);
  } else {
    this->UI->dsmServerName->removeItem(this->UI->dsmServerName->findText(servername));
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onBrowseFile()
{
  QList<QUrl> urls;
  urls << QUrl::fromLocalFile(QDesktopServices::storageLocation(QDesktopServices::HomeLocation));

  QFileDialog dialog;
  dialog.setSidebarUrls(urls);
  dialog.setViewMode(QFileDialog::Detail);
  dialog.setFileMode(QFileDialog::ExistingFile);
  if(dialog.exec()) {
    QString fileName = dialog.selectedFiles().at(0);
    this->UI->xdmfFilePathLineEdit->clear();
    this->UI->xdmfFilePathLineEdit->insert(fileName);
    this->DescFileParse(fileName.toStdString().c_str());
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onBrowseFileImage()
{
  QList<QUrl> urls;
  urls << QUrl::fromLocalFile(QDesktopServices::storageLocation(QDesktopServices::HomeLocation));

  QFileDialog dialog;
  dialog.setSidebarUrls(urls);
  dialog.setViewMode(QFileDialog::Detail);
  dialog.setFileMode(QFileDialog::AnyFile);
  if(dialog.exec()) {
    std::string fileName = dialog.selectedFiles().at(0).toStdString();
    this->UI->imageFilePath->clear();
    fileName = vtksys::SystemTools::GetFilenamePath(fileName) + "/" +
      vtksys::SystemTools::GetFilenameWithoutLastExtension(fileName) + ".xxxxx.png";
    this->UI->imageFilePath->insert(QString(fileName.c_str()));
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onPublishDSM()
{
  if (this->DSMReady() && !this->Connected) {
    if (this->DSMCommType == H5FD_DSM_COMM_SOCKET) {
      QString hostname = this->UI->dsmServerName->currentText();
      pqSMAdaptor::setElementProperty(
          this->UI->DSMProxy->GetProperty("ServerHostName"),
          hostname.toStdString().c_str());

      pqSMAdaptor::setElementProperty(
          this->UI->DSMProxy->GetProperty("ServerPort"),
          this->UI->xdmfCommPort->value());
    }
    this->UI->DSMProxy->UpdateVTKObjects();
    this->UI->DSMProxy->InvokeCommand("PublishDSM");
    this->Connected = true;
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onUnpublishDSM()
{
  if (this->DSMReady() && this->Connected) {
      this->UI->DSMProxy->InvokeCommand("UnpublishDSM");
      this->Connected = false;
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onArrayItemChanged(QTreeWidgetItem *item, int)
{
  this->ChangeItemState(item);
  // Refresh list of send-able arrays
  for(int i = 0; i < this->UI->dsmArrayTreeWidget->topLevelItemCount(); i++) {
    QTreeWidgetItem *gridItem;
    gridItem = this->UI->dsmArrayTreeWidget->topLevelItem(i);
    for (int j = 0; j < gridItem->childCount(); j++) {
      QTreeWidgetItem *attributeItem = gridItem->child(j);
      this->SteeringParser->GetSteeringConfig()->gridConfig[i].attributeConfig[j].isEnabled = (attributeItem->checkState(0) == Qt::Checked) ? true : false;
      if (this->SteeringParser->GetSteeringConfig()->gridConfig[i].attributeConfig[j].isEnabled) {
        // cerr << this->SteeringParser->GetSteeringConfig()->gridConfig[i].attributeConfig[j].hdfPath << endl;
      }
    }
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::ChangeItemState(QTreeWidgetItem *item)
{
  if (!item)
    return;
  for (int i = 0; i < item->childCount(); i++) {
    QTreeWidgetItem *child = item->child(i);
    child->setCheckState(0, item->checkState(0));
    this->ChangeItemState(child);
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onSCPause()
{
  if (this->DSMReady()) {
    const char *steeringCmd = "pause";
    pqSMAdaptor::setElementProperty(
        this->UI->DSMProxy->GetProperty("SteeringCommand"),
        steeringCmd);
    this->UI->infoCurrentSteeringCommand->clear();
    this->UI->infoCurrentSteeringCommand->insert(steeringCmd);
    this->UI->DSMProxy->UpdateVTKObjects();
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onSCPlay()
{
  if (this->DSMReady()) {
    const char *steeringCmd = "play";
    pqSMAdaptor::setElementProperty(
        this->UI->DSMProxy->GetProperty("SteeringCommand"),
        steeringCmd);
    this->UI->infoCurrentSteeringCommand->clear();
    this->UI->infoCurrentSteeringCommand->insert(steeringCmd);
    this->UI->DSMProxy->UpdateVTKObjects();
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onSCRestart()
{
  if (this->DSMReady()) {
    const char *steeringCmd = "restart";
    pqSMAdaptor::setElementProperty(
        this->UI->DSMProxy->GetProperty("SteeringCommand"),
        steeringCmd);
    this->UI->infoCurrentSteeringCommand->clear();
    this->UI->infoCurrentSteeringCommand->insert(steeringCmd);
    this->UI->DSMProxy->UpdateVTKObjects();
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onSCWriteDisk()
{
  if (this->DSMReady()) {
    // workaround to be able to click multiple times on the disk button
    const char *steeringCmdNone = "none";
    const char *steeringCmd = "disk";

    pqSMAdaptor::setElementProperty(this->UI->DSMProxy->GetProperty("SteeringCommand"),
        steeringCmdNone);
    this->UI->DSMProxy->UpdateVTKObjects();

    pqSMAdaptor::setElementProperty(this->UI->DSMProxy->GetProperty("SteeringCommand"),
        steeringCmd);
    this->UI->infoCurrentSteeringCommand->clear();
    this->UI->infoCurrentSteeringCommand->insert(steeringCmd);
    this->UI->DSMProxy->UpdateVTKObjects();
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onWriteDataToDSM() 
{
  if (this->DSMReady()) {
    if (!this->UI->ActiveSourceProxy) {
      vtkGenericWarningMacro(<<"Nothing to Write");
      return;
    }
    //
    vtkSMProxyManager* pm = vtkSMProxy::GetProxyManager();
    vtkSmartPointer<vtkSMSourceProxy> XdmfWriter =
      vtkSMSourceProxy::SafeDownCast(pm->NewProxy("icarus_helpers", "XdmfWriter4"));

    // Delete our reference now and let smart pointer clean up later
    XdmfWriter->UnRegister(NULL);

    pqSMAdaptor::setProxyProperty(
      XdmfWriter->GetProperty("DSMManager"), this->UI->DSMProxy);

    pqSMAdaptor::setElementProperty(
      XdmfWriter->GetProperty("FileName"), "stdin");

    pqSMAdaptor::setInputProperty(
      XdmfWriter->GetProperty("Input"),
      this->UI->ActiveSourceProxy,
      this->UI->ActiveSourcePort
      );

    XdmfWriter->UpdateVTKObjects();
    XdmfWriter->UpdatePipeline();
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onAdvancedControlUpdate()
{
/*
  if (this->DSMReady()) {
    for (unsigned int i = 0; i < this->advancedControlIntScalarSpinBoxes.size(); i++) {
      pqSMAdaptor::setElementProperty(
          this->UI->DSMProxy->GetProperty("IntScalarInteractionName"),
          this->advancedControlIntScalarSpinBoxesLabels[i]->text().toStdString().c_str());
      pqSMAdaptor::setElementProperty(
          this->UI->DSMProxy->GetProperty("IntScalarInteraction"),
          this->advancedControlIntScalarSpinBoxes[i]->value());
      cerr << this->advancedControlIntScalarSpinBoxes[i]->value() << endl;
//      this->UI->DSMProxy->Modified();
      this->UI->DSMProxy->UpdateVTKObjects();
    }
    for (unsigned int i = 0; i < this->advancedControlIntScalarComboBoxes.size(); i++) {
      pqSMAdaptor::setElementProperty(
          this->UI->DSMProxy->GetProperty("IntScalarInteractionName"),
          this->advancedControlIntScalarComboBoxesLabels[i]->text().toStdString().c_str());
      pqSMAdaptor::setElementProperty(
          this->UI->DSMProxy->GetProperty("IntScalarInteraction"),
          (int)this->advancedControlIntScalarComboBoxes[i]->currentIndex());
      cerr << this->advancedControlIntScalarComboBoxes[i]->currentIndex() << endl;
//      this->UI->DSMProxy->Modified();
      this->UI->DSMProxy->UpdateVTKObjects();
    }
    for (unsigned int i = 0; i < this->advancedControlDoubleScalarSpinBoxes.size(); i++) {
      pqSMAdaptor::setElementProperty(
          this->UI->DSMProxy->GetProperty("DoubleScalarInteractionName"),
          this->advancedControlDoubleScalarLabels[i]->text().toStdString().c_str());
      pqSMAdaptor::setElementProperty(
          this->UI->DSMProxy->GetProperty("DoubleScalarInteraction"),
          this->advancedControlDoubleScalarSpinBoxes[i]->value());
      cerr << this->advancedControlDoubleScalarSpinBoxes[i]->value() << endl;
//      this->UI->DSMProxy->Modified();
      this->UI->DSMProxy->UpdateVTKObjects();
    }
  }
  */
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::SaveSnapshot() {
  std::string pngname = this->UI->imageFilePath->text().toStdString();
  vtksys::SystemTools::ReplaceString(pngname, "xxxxx", "%05i");
  char buffer[1024];
  sprintf(buffer, pngname.c_str(), this->CurrentTimeStep);  
  pqActiveObjects::instance().activeView()->saveImage(0, 0, QString(buffer));
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onautoSaveImageChecked(int checked)
{
  if (checked) {
    SaveSnapshot();
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onDisplayDSM()
{
  bool force_generate     = false;
  static bool first_time  = true;
  static int current_time = 0;
  static std::string xdmf_description_file_path = this->UI->xdmfFilePathLineEdit->text().toStdString();


  if (this->UI->ProxyCreated() && this->UI->DSMInitialized && this->DSMReady()) {
    vtkSMProxyManager *pm = vtkSMProxy::GetProxyManager();

#ifdef DISABLE_DISPLAY
    if (this->DSMReady()) {
      this->UI->DSMProxy->InvokeCommand("H5DumpLight");
    }
#else
    if (!this->XdmfReader || this->UI->storeDSMContents->isChecked()) {
      //
      // Create a new Reader proxy and register it with the system
      //
      char proxyName[256];

      // When creating reader, make sure first_time is true
      if (!first_time) first_time = true;
      if (this->XdmfReader) this->XdmfReader.New();
      this->XdmfReader.TakeReference(vtkSMSourceProxy::SafeDownCast(pm->NewProxy("icarus_helpers", "XdmfReader4")));
      this->XdmfReader->SetConnectionID(pqActiveObjects::instance().activeServer()->GetConnectionID());
      this->XdmfReader->SetServers(vtkProcessModule::DATA_SERVER);
      sprintf(proxyName, "DSMDataSource%d", current_time);
      pm->RegisterProxy("sources", proxyName, this->XdmfReader);

      //
      // Connect our DSM manager to the reader
      //
      pqSMAdaptor::setProxyProperty(
          this->XdmfReader->GetProperty("DSMManager"), this->UI->DSMProxy
        );
    }

    //
    // If we are using an Xdmf XML file supplied manually or generated, get it
    //
    if (this->UI->xdmfFileTypeComboBox->currentIndex() != 2) { //if not use sent XML
      if (!this->UI->xdmfFilePathLineEdit->text().isEmpty()) {
        if (this->UI->xdmfFileTypeComboBox->currentIndex() == 0) { // Original XDMF File
          pqSMAdaptor::setElementProperty(
              this->XdmfReader->GetProperty("FileName"),
              this->UI->xdmfFilePathLineEdit->text().toStdString().c_str());
        }
        if (this->UI->xdmfFileTypeComboBox->currentIndex() == 1) { // XDMF Template File
          force_generate = (this->UI->forceXdmfGeneration->isChecked()) ? true : false;
          // Only re-generate if the description file path has changed or if force is set to true
          if ((xdmf_description_file_path != this->UI->xdmfFilePathLineEdit->text().toStdString()) || first_time || force_generate) {
            xdmf_description_file_path = this->UI->xdmfFilePathLineEdit->text().toStdString();
            // Generate xdmf file for reading
            // Send the whole string representing the DOM and not the file path so that the template file
            // does not to be present on the server anymore
            pqSMAdaptor::setElementProperty(
                this->UI->DSMProxy->GetProperty("XMFDescriptionFilePath"),
                this->SteeringParser->GetConfigDOM()->Serialize());

            this->UI->DSMProxy->UpdateVTKObjects();
            this->UI->DSMProxy->InvokeCommand("GenerateXMFDescription");
          }
        }
      }
    }
    else {
      pqSMAdaptor::setElementProperty(
        this->XdmfReader->GetProperty("FileName"), "stdin");
    }

    QTime dieTime = QTime::currentTime().addMSecs(10);
    while( QTime::currentTime() < dieTime ) {
      QCoreApplication::processEvents(QEventLoop::AllEvents, 10);
    }

    //
    // Update before setting up representation to ensure correct 'type' is created
    // Remember that Xdmf supports many data types Regular/Unstructured/etc
    //
    this->XdmfReader->InvokeCommand("Modified");
    this->XdmfReader->UpdatePropertyInformation();
    this->XdmfReader->UpdateVTKObjects();
    this->XdmfReader->UpdatePipeline();

    //
    // Create a representation if we need one : First time or if storing multiple datasets
    //
    if (!this->XdmfRepresentation || this->UI->storeDSMContents->isChecked()) {
      this->XdmfRepresentation = pqActiveObjects::instance().activeView()->getViewProxy()->CreateDefaultRepresentation(this->XdmfReader, 0);
    }

    //
    // Create a pipeline source to appear in the GUI, 
    // findItem creates a new one initially, thenafter returns the same object
    // Mark the item as Unmodified since we manually updated the pipeline ourselves
    //
    pqPipelineSource* source = pqApplicationCore::instance()->
      getServerManagerModel()->findItem<pqPipelineSource*>(this->XdmfReader);
    source->setModifiedState(pqProxy::UNMODIFIED);

    //
    // on First creation, make the object visible.
    //
    if (first_time) {
      pqDisplayPolicy* display_policy = pqApplicationCore::instance()->getDisplayPolicy();
      pqOutputPort *port = source->getOutputPort(0);
      display_policy->setRepresentationVisibility(port, pqActiveObjects::instance().activeView(), 1);
      //
      first_time = false;
    }

    // 
    // Increment the time as new steps appear.
    // @TODO : To be replaced with GetTimeStep from reader
    //
    QList<pqAnimationScene*> scenes = pqApplicationCore::instance()->getServerManagerModel()->findItems<pqAnimationScene *>();
    foreach (pqAnimationScene *scene, scenes) {
      scene->setAnimationTime(++current_time);
      this->CurrentTimeStep = current_time;
    }

    dieTime = QTime::currentTime().addMSecs(10);
    while( QTime::currentTime() < dieTime )
	    QCoreApplication::processEvents(QEventLoop::AllEvents, 10);

    //
    // Trigger a render : if changed, everything should update as usual
    if (pqActiveObjects::instance().activeView())
    {
      pqActiveObjects::instance().activeView()->render();
      if (this->UI->autoSaveImage->isChecked()) {
        this->SaveSnapshot();
      }
    }
#endif //DISABLE_DISPLAY

    //
    // To prevent deadlock, switch communicators if we are client and server
    //
//    this->UI->DSMProxy->InvokeCommand("RequestRemoteChannel");
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::TrackSource()
{
  //find the active filter
  pqServerManagerModelItem *item =
    pqApplicationCore::instance()->getSelectionModel()->currentItem();
  if (item)
  {
    pqOutputPort* port = qobject_cast<pqOutputPort*>(item);
    this->UI->ActiveSourcePort = port ? port->getPortNumber() : 0;
    pqPipelineSource *source = port ? port->getSource() : 
      qobject_cast<pqPipelineSource*>(item);
    if (source)
    {
      this->UI->ActiveSourceProxy = source->getProxy();
      this->UI->infoTextOutput->clear();
      this->UI->infoTextOutput->insert(
        this->UI->ActiveSourceProxy->GetVTKClassName()
        );
    }
    else {
      this->UI->ActiveSourceProxy = NULL;
      this->UI->infoTextOutput->clear();
    }
  }
  else {
    this->UI->ActiveSourceProxy = NULL;
    this->UI->infoTextOutput->clear();
  }
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::onUpdateTimeout()
{
  // make sure we only get one message at a time.
  this->UpdateTimer->stop();

  // we don't want to create anything just to inspect it, so test flags only
  if (this->UI->ProxyCreated() && this->UI->DSMInitialized) {
    if (this->DSMReady()) {
      vtkSMIntVectorProperty *ur = vtkSMIntVectorProperty::SafeDownCast(
        this->UI->DSMProxy->GetProperty("DsmUpdateReady"));
      this->UI->DSMProxy->UpdatePropertyInformation(ur);
      int ready = ur->GetElement(0);
      if (ready != 0) {
        this->UI->DSMProxy->InvokeCommand("ClearDsmUpdateReady");
        if (this->UI->autoDisplayDSM->isChecked()) {
          this->onDisplayDSM();
        } 
        // TODO If the XdmfWriter has to write something back to the DSM, it's here
        if (!this->UI->dsmIsStandalone->isChecked()) {
          this->UI->DSMProxy->InvokeCommand("RequestRemoteChannel");
        }
      }
    }
  }

  // restart the timer before we exit
  this->UpdateTimer->start();
}
//-----------------------------------------------------------------------------
void pqDSMViewerPanel::toggleHandleWidget(int state)
{
  if (this->UI->ActiveView==NULL && pqActiveView::instance().current()) {
    this->onActiveViewChanged(pqActiveView::instance().current());
  }

  if (!this->XdmfReader) {
    return;
  }

  if (!this->HandleProxy) {
    vtkSMProxyManager *pm = vtkSMProxy::GetProxyManager();


//    this->HandleProxy = pm->NewProxy("extended_sources", "Transform3");
    this->HandleProxy = pm->NewProxy("3d_widgets", "HandleWidget");
    this->HandleProxy->SetConnectionID(pqActiveObjects::instance().activeServer()->GetConnectionID());
    this->HandleProxy->UpdatePropertyInformation();

    dsmStandardWidgets standardWidgets;
    this->HandleWidget = standardWidgets.newWidget("Distance", this->XdmfReader, this->HandleProxy);

    this->HandleWidget->resetBounds();
    this->HandleWidget->reset();

    QGridLayout* l = qobject_cast<QGridLayout*>(this->UI->devTab->layout());
    l->addWidget(this->HandleWidget, 1, 0, 1, 2);
    if (this->UI->ActiveView==NULL && pqActiveView::instance().current()) {
      this->onActiveViewChanged(pqActiveView::instance().current());
    }
    this->HandleWidget->setView(this->UI->ActiveView);
    this->HandleWidget->show();
  }

  this->HandleWidget->select();
  this->HandleWidget->showWidget();
}
//-----------------------------------------------------------------------------
